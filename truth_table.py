'''
For KIT103/KMA115 Practical 4: Logic
Revised: 2015-07-11
Author: James Montgomery (james.montgomery@utas.edu.au)

The truth_table function can generate truth tables given a predicate
and the number of variables that predicate works with. Also includes a
helper function eval_predicate which returns a list corresponding to
the last column in the truth table (useful for comparing the outcomes
of two different predicates).

The module also includes one correct and one broken implementation of
an 'implies' operator, as in p --> q.
'''

from itertools import product
from string import ascii_lowercase as names

def truth_table(p, n, binary=False):
    '''Draws the truth table for the given predicate of n parameters.

    For instance, given a predicate defined as
    def pred(a, b, c):
        return a and b and not c
    create the truth table with truth_table(pred, 3).

    Set the paramter 'binary' to True to display the truth table as
    zeroes and ones instead of Falses and Trues.\
    '''
    display_func = str if not binary else (lambda t: '1' if t else '0')
    sep = '  ' if binary else '\t' #use compact display with 0 and 1 outputs
    inputs = product([False, True], repeat=n)
    print(sep.join(names[:n]) + sep + '| p')
    print('-' * (len(sep) + 1 if binary else 8) * (n+1))
    for t in inputs:
        print(sep.join(map(display_func, t)) + sep + '| ' + display_func(p(*t)))

def eval_predicate(p, n):
    '''Evaluates the predicate of n parameters over all possible
    inputs and returns a list of the outcomes. Equivalent (in content)
    to the last column generated by truth_table(). You are not
    expected to understand the code below.
    '''
    return [p(*i) for i in product([False, True], repeat=n)]

def implies(p, q):
    '''Returns the result of p implies q, i.e., p --> q.'''
    return not p or q

def naive_implies(p, q):
    '''p --> q naively implemented assuming that 'if p then q' is the same.'''
    if p:
        return q
    return True


def truth_table_explained(p, n, binary=False):
    '''The truth_table function with each part explained in detail.
    This is only for those who are interested
    '''
    #These two lines determine how values of True and False will be displayed,
    #either as True and False or 1 and 0
    display_func = str if not binary else (lambda t: '1' if t else '0')
    sep = '  ' if binary else '\t' #use compact display with 0 and 1 outputs
        
    #product() returns a generator the produces the elements of the Cartesian
    #product over one or multiple different sets
    # see https://docs.python.org/3/library/itertools.html#itertools.product
    inputs = product([False, True], repeat=n)

    #ascii_lowercase (from the string module), and imported with the shorter
    #identifier 'names', is a string of lowercase alphabetic characters
    # see https://docs.python.org/3/library/string.html#string.ascii_lowercase
    #the [:n] selects a slice of the string from the start to the character at
    #position n-1
    # see https://docs.python.org/3/tutorial/introduction.html#strings
    #join concatenates each element of an iterable with the string sep between them
    # see https://docs.python.org/3/library/stdtypes.html?highlight=join#str.join
    print(sep.join(names[:n]) + sep + '| p')

    #'multiplying' a string by an integer concatenates the string with iteself that many times
    print('-' * (len(sep) + 1 if binary else 8) * (n+1))

    for t in inputs:
        #Since t is a tuple, but p is a function that takes n arguments we need to 'unpack' these from the tuple: *t does this unpacking.
        # see https://docs.python.org/2/tutorial/controlflow.html#unpacking-argument-lists
        #join needs an iterable collection of strings, but since boolean values are not strings we need to convert them all.
        #The map function applies another function (in this case str) to every element of an iterable and returns a list of the results
        # see https://docs.python.org/2/library/functions.html#map
        print(sep.join(map(display_func, t)) + sep + '| ' + display_func(p(*t)))

def negate(p):
    return not p
def my_and(p,q):
    return p and q
def my_or(p,q):
    return p or q

p1 = lambda a,b,c : not a and not b and not c
p2 = lambda a,b: a or b and a
p3 = lambda a: a and not a
p4 = lambda a, b: (a and b) or (not a and b)
def p5(a,b,c):
    return (a or b) and (a or c)
p1new = lambda a,b,c: not (a or b or c)
p2new = lambda a,b: a
p3new = lambda a : False
p4new = lambda a,b: b
def p5new(a,b,c):
    return a or b and c

def exists(s,p):
    for i in s:
        if  p(i):
            return True
    return False
def for_all(s,p):
    for i in s:
        if not p(i):
            return False
    return True

words = {   line.rstrip() for line in open('tlw.txt')   } 
def p(w):
   if w[-1] =='q': # argument -1 is equal to arugment 2
       return True
   return False


